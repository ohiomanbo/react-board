<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name = "viewport" content="width=device-width, initial-scale=1">
    <title>Document</title>
</head>

<body>
    <script>
        // concat, filter, map, spread
        const a = [1,2,3]
        const b = [...a] // 깊은 복사

        console.log(a)
        console.log(b)

        b.push(4)
        console.log(`a의 값은 : ${a}`)
        console.log(`b의 값은 : ${b}`)

        const c = [0, ...a, 4]
        console.log(`c의 값은 : ${c}`) // c의 값은 : 0, 1, 2, 3, 4



        const a2 = [1,2,3]
        const b2=a2.concat(4)

        console.log(`a의 값은 : ${a2}`)
        console.log(`b의 값은 : ${b2}`)

        const c2 = a2.push(4)

        console.log(`a의 값은 : ${a2}`)
        console.log(`c의 값은 : ${c2}`)    

        a2.push(5)

        console.log(`a의 값은 : ${a2}`)


        const a3 = [1, 2, 3]
        const b3 = a3.filter(element => {return element !== 1}) // bool을 return 받음. -> true만 걸러내줌
        console.log(b3)


        const a4 = [1, 2, 3]
        const b4 = a4.slice(0,2)

        console.log(`b의 값은 : ${b4}`) // b의 값은 : 1, 2

        const c3 = [a4.slice(0,2)]

        console.log(b4) // [1, 2]
        console.log(c3) // [[1, 2]]

        const c4 = [...a4.slice(0,2)] // [1, 2]

        const c5 = [...a4.slice(0,2), 4, ...a4.slice(2,3)]
        console.log(c5) // [1, 2, 4, 3]

        
        const a5 = [1, 2, 3]
        a5.forEach( (n) => { console.log(n) }) // callback function이 forEach 안에 들어감. jsx에서는 그냥 for문 불가. forEach는 리턴이 없음
        // const c5 = a5.forEach ... 해봤자 null 값 들어감

        const b5 = a5.map( (n) => n === 2 ? n*10 : n ) // return 타입이 any임. 화살표 다음 중괄호 없으면 바로 return, 중괄호 치면 return 필요시 입력해야됨.
        // === const b5 = [...a5]
        // map은 값 하나하나를 가공할 수 있음

        console.log(b5) // 1, 20, 3
        

        const a6 = { id : 1, name : "hkd", phone : "0000" }
        const b6 = {...a6, name : "kd" }

        console.log(b6) // { id : 1, name : "kd" , phone : "0000" } id, phone 그대로 있고 name만 바뀜

        const phoneDto = { phone: "1111"}
        const c6 = {...a6, ...phoneDto}
        console.log(c6) // { id : 1, name : "hkd", phone : "1111" }

        const d = {...phoneDto, ...a6}
        console.log(d) // { phone : "0000", id : 1, name : "hkd" } 뒤에 값이 덮어 씌움


        const users = [
            { id : 1, name : "kch", phone : "1111" },
            { id : 2, name : "ch", phone : "2222" },
            { id : 3, name : "ohio", phone : "3333" }
        ]

        const updateUserDto = {
            id : 2, name : "manbo"
        }
    
        // users[1].name = updateUseDto.name 원본이 변경되어 최적화 못시킴
        const newUser = users.map( n => n.id === updateUserDto.id ? {...n, ...updateUserDto} : n)
        console.log(newUser) // [ {...}, { id : 2, name : "manbo", phone "2222"}, {...} ]


        </script>
</body>
</html>